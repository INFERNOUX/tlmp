// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "network.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace TLMP {
namespace NetworkMessages {

namespace {

const ::google::protobuf::Descriptor* Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Position_reflection_ = NULL;
const ::google::protobuf::Descriptor* Character_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Character_reflection_ = NULL;
const ::google::protobuf::Descriptor* Equipment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Equipment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Version_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Version_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameHasStarted_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameHasStarted_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameStarted_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameStarted_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameEnded_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameEnded_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameEnter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameEnter_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameExited_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameExited_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestCharacterInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestCharacterInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReplyCharacterInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReplyCharacterInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReplyCharacterId_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReplyCharacterId_reflection_ = NULL;
const ::google::protobuf::Descriptor* CharacterDestination_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CharacterDestination_reflection_ = NULL;
const ::google::protobuf::Descriptor* InventoryAddEquipment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InventoryAddEquipment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Item_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Item_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemDrop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemDrop_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemPickup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemPickup_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemEquip_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemEquip_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemUnequip_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemUnequip_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_network_2eproto() {
  protobuf_AddDesc_network_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "network.proto");
  GOOGLE_CHECK(file != NULL);
  Position_descriptor_ = file->message_type(0);
  static const int Position_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, z_),
  };
  Position_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Position_descriptor_,
      Position::default_instance_,
      Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Position, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Position));
  Character_descriptor_ = file->message_type(1);
  static const int Character_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, guid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, minion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, id_),
  };
  Character_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Character_descriptor_,
      Character::default_instance_,
      Character_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Character, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Character));
  Equipment_descriptor_ = file->message_type(2);
  static const int Equipment_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Equipment, guid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Equipment, slot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Equipment, id_),
  };
  Equipment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Equipment_descriptor_,
      Equipment::default_instance_,
      Equipment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Equipment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Equipment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Equipment));
  Version_descriptor_ = file->message_type(3);
  static const int Version_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, version_),
  };
  Version_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Version_descriptor_,
      Version::default_instance_,
      Version_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Version));
  GameHasStarted_descriptor_ = file->message_type(4);
  static const int GameHasStarted_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameHasStarted, started_),
  };
  GameHasStarted_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameHasStarted_descriptor_,
      GameHasStarted::default_instance_,
      GameHasStarted_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameHasStarted, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameHasStarted, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameHasStarted));
  GameStarted_descriptor_ = file->message_type(5);
  static const int GameStarted_offsets_[1] = {
  };
  GameStarted_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameStarted_descriptor_,
      GameStarted::default_instance_,
      GameStarted_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameStarted, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameStarted, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameStarted));
  GameEnded_descriptor_ = file->message_type(6);
  static const int GameEnded_offsets_[1] = {
  };
  GameEnded_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameEnded_descriptor_,
      GameEnded::default_instance_,
      GameEnded_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEnded, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEnded, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameEnded));
  GameEnter_descriptor_ = file->message_type(7);
  static const int GameEnter_offsets_[1] = {
  };
  GameEnter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameEnter_descriptor_,
      GameEnter::default_instance_,
      GameEnter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEnter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameEnter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameEnter));
  GameExited_descriptor_ = file->message_type(8);
  static const int GameExited_offsets_[1] = {
  };
  GameExited_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GameExited_descriptor_,
      GameExited::default_instance_,
      GameExited_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameExited, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameExited, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GameExited));
  RequestCharacterInfo_descriptor_ = file->message_type(9);
  static const int RequestCharacterInfo_offsets_[1] = {
  };
  RequestCharacterInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RequestCharacterInfo_descriptor_,
      RequestCharacterInfo::default_instance_,
      RequestCharacterInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCharacterInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCharacterInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RequestCharacterInfo));
  ReplyCharacterInfo_descriptor_ = file->message_type(10);
  static const int ReplyCharacterInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplyCharacterInfo, player_),
  };
  ReplyCharacterInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReplyCharacterInfo_descriptor_,
      ReplyCharacterInfo::default_instance_,
      ReplyCharacterInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplyCharacterInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplyCharacterInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReplyCharacterInfo));
  ReplyCharacterId_descriptor_ = file->message_type(11);
  static const int ReplyCharacterId_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplyCharacterId, id_),
  };
  ReplyCharacterId_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReplyCharacterId_descriptor_,
      ReplyCharacterId::default_instance_,
      ReplyCharacterId_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplyCharacterId, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReplyCharacterId, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReplyCharacterId));
  CharacterDestination_descriptor_ = file->message_type(12);
  static const int CharacterDestination_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CharacterDestination, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CharacterDestination, current_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CharacterDestination, destination_),
  };
  CharacterDestination_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CharacterDestination_descriptor_,
      CharacterDestination::default_instance_,
      CharacterDestination_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CharacterDestination, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CharacterDestination, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CharacterDestination));
  InventoryAddEquipment_descriptor_ = file->message_type(13);
  static const int InventoryAddEquipment_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InventoryAddEquipment, ownerid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InventoryAddEquipment, equipmentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InventoryAddEquipment, slot_),
  };
  InventoryAddEquipment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InventoryAddEquipment_descriptor_,
      InventoryAddEquipment::default_instance_,
      InventoryAddEquipment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InventoryAddEquipment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InventoryAddEquipment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InventoryAddEquipment));
  Entity_descriptor_ = file->message_type(14);
  static const int Entity_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, guid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, noitems_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, destination_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, position_),
  };
  Entity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entity_descriptor_,
      Entity::default_instance_,
      Entity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entity));
  Item_descriptor_ = file->message_type(15);
  static const int Item_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, guid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, unk0_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, unk1_),
  };
  Item_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Item_descriptor_,
      Item::default_instance_,
      Item_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Item));
  ItemDrop_descriptor_ = file->message_type(16);
  static const int ItemDrop_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemDrop, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemDrop, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemDrop, unk0_),
  };
  ItemDrop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemDrop_descriptor_,
      ItemDrop::default_instance_,
      ItemDrop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemDrop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemDrop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemDrop));
  ItemPickup_descriptor_ = file->message_type(17);
  static const int ItemPickup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemPickup, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemPickup, ownerid_),
  };
  ItemPickup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemPickup_descriptor_,
      ItemPickup::default_instance_,
      ItemPickup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemPickup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemPickup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemPickup));
  ItemEquip_descriptor_ = file->message_type(18);
  static const int ItemEquip_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemEquip, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemEquip, slot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemEquip, ownerid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemEquip, unk_),
  };
  ItemEquip_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemEquip_descriptor_,
      ItemEquip::default_instance_,
      ItemEquip_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemEquip, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemEquip, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemEquip));
  ItemUnequip_descriptor_ = file->message_type(19);
  static const int ItemUnequip_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemUnequip, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemUnequip, ownerid_),
  };
  ItemUnequip_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemUnequip_descriptor_,
      ItemUnequip::default_instance_,
      ItemUnequip_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemUnequip, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemUnequip, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemUnequip));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_network_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Position_descriptor_, &Position::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Character_descriptor_, &Character::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Equipment_descriptor_, &Equipment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Version_descriptor_, &Version::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameHasStarted_descriptor_, &GameHasStarted::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameStarted_descriptor_, &GameStarted::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameEnded_descriptor_, &GameEnded::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameEnter_descriptor_, &GameEnter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GameExited_descriptor_, &GameExited::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RequestCharacterInfo_descriptor_, &RequestCharacterInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReplyCharacterInfo_descriptor_, &ReplyCharacterInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReplyCharacterId_descriptor_, &ReplyCharacterId::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CharacterDestination_descriptor_, &CharacterDestination::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InventoryAddEquipment_descriptor_, &InventoryAddEquipment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entity_descriptor_, &Entity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Item_descriptor_, &Item::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemDrop_descriptor_, &ItemDrop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemPickup_descriptor_, &ItemPickup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemEquip_descriptor_, &ItemEquip::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemUnequip_descriptor_, &ItemUnequip::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_network_2eproto() {
  delete Position::default_instance_;
  delete Position_reflection_;
  delete Character::default_instance_;
  delete Character_reflection_;
  delete Equipment::default_instance_;
  delete Equipment_reflection_;
  delete Version::default_instance_;
  delete Version_reflection_;
  delete GameHasStarted::default_instance_;
  delete GameHasStarted_reflection_;
  delete GameStarted::default_instance_;
  delete GameStarted_reflection_;
  delete GameEnded::default_instance_;
  delete GameEnded_reflection_;
  delete GameEnter::default_instance_;
  delete GameEnter_reflection_;
  delete GameExited::default_instance_;
  delete GameExited_reflection_;
  delete RequestCharacterInfo::default_instance_;
  delete RequestCharacterInfo_reflection_;
  delete ReplyCharacterInfo::default_instance_;
  delete ReplyCharacterInfo_reflection_;
  delete ReplyCharacterId::default_instance_;
  delete ReplyCharacterId_reflection_;
  delete CharacterDestination::default_instance_;
  delete CharacterDestination_reflection_;
  delete InventoryAddEquipment::default_instance_;
  delete InventoryAddEquipment_reflection_;
  delete Entity::default_instance_;
  delete Entity_reflection_;
  delete Item::default_instance_;
  delete Item_reflection_;
  delete ItemDrop::default_instance_;
  delete ItemDrop_reflection_;
  delete ItemPickup::default_instance_;
  delete ItemPickup_reflection_;
  delete ItemEquip::default_instance_;
  delete ItemEquip_reflection_;
  delete ItemUnequip::default_instance_;
  delete ItemUnequip_reflection_;
}

void protobuf_AddDesc_network_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rnetwork.proto\022\024TLMP.NetworkMessages\"+\n"
    "\010Position\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002"
    "(\002\"\226\001\n\tCharacter\022\014\n\004guid\030\001 \002(\003\022\014\n\004name\030\002"
    " \002(\t\022/\n\006minion\030\003 \003(\0132\037.TLMP.NetworkMessa"
    "ges.Character\0220\n\010position\030\004 \003(\0132\036.TLMP.N"
    "etworkMessages.Position\022\n\n\002id\030\005 \001(\005\"3\n\tE"
    "quipment\022\014\n\004guid\030\001 \002(\003\022\014\n\004slot\030\002 \001(\005\022\n\n\002"
    "id\030\003 \002(\005\"\032\n\007Version\022\017\n\007version\030\001 \002(\005\"!\n\016"
    "GameHasStarted\022\017\n\007started\030\001 \002(\010\"\r\n\013GameS"
    "tarted\"\013\n\tGameEnded\"\013\n\tGameEnter\"\014\n\nGame"
    "Exited\"\026\n\024RequestCharacterInfo\"E\n\022ReplyC"
    "haracterInfo\022/\n\006player\030\001 \003(\0132\037.TLMP.Netw"
    "orkMessages.Character\"\036\n\020ReplyCharacterI"
    "d\022\n\n\002id\030\001 \002(\005\"\210\001\n\024CharacterDestination\022\n"
    "\n\002id\030\001 \002(\005\022/\n\007current\030\002 \003(\0132\036.TLMP.Netwo"
    "rkMessages.Position\0223\n\013destination\030\003 \003(\013"
    "2\036.TLMP.NetworkMessages.Position\"K\n\025Inve"
    "ntoryAddEquipment\022\017\n\007ownerId\030\001 \002(\005\022\023\n\013eq"
    "uipmentId\030\002 \002(\005\022\014\n\004slot\030\003 \002(\005\"\251\001\n\006Entity"
    "\022\n\n\002id\030\001 \002(\005\022\r\n\005level\030\002 \002(\005\022\014\n\004guid\030\003 \002("
    "\003\022\017\n\007noItems\030\004 \002(\010\0223\n\013destination\030\005 \001(\0132"
    "\036.TLMP.NetworkMessages.Position\0220\n\010posit"
    "ion\030\006 \003(\0132\036.TLMP.NetworkMessages.Positio"
    "n\"K\n\004Item\022\n\n\002id\030\001 \002(\005\022\014\n\004guid\030\002 \002(\003\022\r\n\005l"
    "evel\030\003 \002(\005\022\014\n\004unk0\030\004 \002(\005\022\014\n\004unk1\030\005 \002(\005\"V"
    "\n\010ItemDrop\022\n\n\002id\030\001 \002(\005\0220\n\010position\030\002 \003(\013"
    "2\036.TLMP.NetworkMessages.Position\022\014\n\004unk0"
    "\030\003 \002(\010\")\n\nItemPickup\022\n\n\002id\030\001 \002(\005\022\017\n\007owne"
    "rId\030\002 \002(\005\"C\n\tItemEquip\022\n\n\002id\030\001 \002(\005\022\014\n\004sl"
    "ot\030\002 \002(\005\022\017\n\007ownerId\030\003 \002(\005\022\013\n\003unk\030\004 \002(\005\"*"
    "\n\013ItemUnequip\022\n\n\002id\030\001 \002(\005\022\017\n\007ownerid\030\002 \002"
    "(\005", 1242);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "network.proto", &protobuf_RegisterTypes);
  Position::default_instance_ = new Position();
  Character::default_instance_ = new Character();
  Equipment::default_instance_ = new Equipment();
  Version::default_instance_ = new Version();
  GameHasStarted::default_instance_ = new GameHasStarted();
  GameStarted::default_instance_ = new GameStarted();
  GameEnded::default_instance_ = new GameEnded();
  GameEnter::default_instance_ = new GameEnter();
  GameExited::default_instance_ = new GameExited();
  RequestCharacterInfo::default_instance_ = new RequestCharacterInfo();
  ReplyCharacterInfo::default_instance_ = new ReplyCharacterInfo();
  ReplyCharacterId::default_instance_ = new ReplyCharacterId();
  CharacterDestination::default_instance_ = new CharacterDestination();
  InventoryAddEquipment::default_instance_ = new InventoryAddEquipment();
  Entity::default_instance_ = new Entity();
  Item::default_instance_ = new Item();
  ItemDrop::default_instance_ = new ItemDrop();
  ItemPickup::default_instance_ = new ItemPickup();
  ItemEquip::default_instance_ = new ItemEquip();
  ItemUnequip::default_instance_ = new ItemUnequip();
  Position::default_instance_->InitAsDefaultInstance();
  Character::default_instance_->InitAsDefaultInstance();
  Equipment::default_instance_->InitAsDefaultInstance();
  Version::default_instance_->InitAsDefaultInstance();
  GameHasStarted::default_instance_->InitAsDefaultInstance();
  GameStarted::default_instance_->InitAsDefaultInstance();
  GameEnded::default_instance_->InitAsDefaultInstance();
  GameEnter::default_instance_->InitAsDefaultInstance();
  GameExited::default_instance_->InitAsDefaultInstance();
  RequestCharacterInfo::default_instance_->InitAsDefaultInstance();
  ReplyCharacterInfo::default_instance_->InitAsDefaultInstance();
  ReplyCharacterId::default_instance_->InitAsDefaultInstance();
  CharacterDestination::default_instance_->InitAsDefaultInstance();
  InventoryAddEquipment::default_instance_->InitAsDefaultInstance();
  Entity::default_instance_->InitAsDefaultInstance();
  Item::default_instance_->InitAsDefaultInstance();
  ItemDrop::default_instance_->InitAsDefaultInstance();
  ItemPickup::default_instance_->InitAsDefaultInstance();
  ItemEquip::default_instance_->InitAsDefaultInstance();
  ItemUnequip::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_network_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_network_2eproto {
  StaticDescriptorInitializer_network_2eproto() {
    protobuf_AddDesc_network_2eproto();
  }
} static_descriptor_initializer_network_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Position::kXFieldNumber;
const int Position::kYFieldNumber;
const int Position::kZFieldNumber;
#endif  // !_MSC_VER

Position::Position()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Position::InitAsDefaultInstance() {
}

Position::Position(const Position& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Position::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Position::~Position() {
  SharedDtor();
}

void Position::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Position_descriptor_;
}

const Position& Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

Position* Position::default_instance_ = NULL;

Position* Position::New() const {
  return new Position;
}

void Position::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }
      
      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
  // required float z = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }
  
  // required float y = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }
  
  // required float z = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Position::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Position::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Position* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Position*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Position::MergeFrom(const Position& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_x(from.x());
    }
    if (from._has_bit(1)) {
      set_y(from.y());
    }
    if (from._has_bit(2)) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Position::CopyFrom(const Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Position::Swap(Position* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Position_descriptor_;
  metadata.reflection = Position_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Character::_default_name_;
#ifndef _MSC_VER
const int Character::kGuidFieldNumber;
const int Character::kNameFieldNumber;
const int Character::kMinionFieldNumber;
const int Character::kPositionFieldNumber;
const int Character::kIdFieldNumber;
#endif  // !_MSC_VER

Character::Character()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Character::InitAsDefaultInstance() {
}

Character::Character(const Character& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Character::SharedCtor() {
  _cached_size_ = 0;
  guid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&_default_name_);
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Character::~Character() {
  SharedDtor();
}

void Character::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Character::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Character::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Character_descriptor_;
}

const Character& Character::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

Character* Character::default_instance_ = NULL;

Character* Character::New() const {
  return new Character;
}

void Character::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    guid_ = GOOGLE_LONGLONG(0);
    if (_has_bit(1)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    id_ = 0;
  }
  minion_.Clear();
  position_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Character::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &guid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_minion;
        break;
      }
      
      // repeated .TLMP.NetworkMessages.Character minion = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_minion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_minion()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_minion;
        if (input->ExpectTag(34)) goto parse_position;
        break;
      }
      
      // repeated .TLMP.NetworkMessages.Position position = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_position;
        if (input->ExpectTag(40)) goto parse_id;
        break;
      }
      
      // optional int32 id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Character::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 guid = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->guid(), output);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // repeated .TLMP.NetworkMessages.Character minion = 3;
  for (int i = 0; i < this->minion_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->minion(i), output);
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 4;
  for (int i = 0; i < this->position_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->position(i), output);
  }
  
  // optional int32 id = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Character::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 guid = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->guid(), target);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // repeated .TLMP.NetworkMessages.Character minion = 3;
  for (int i = 0; i < this->minion_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->minion(i), target);
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 4;
  for (int i = 0; i < this->position_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->position(i), target);
  }
  
  // optional int32 id = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Character::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 guid = 1;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->guid());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional int32 id = 5;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
  }
  // repeated .TLMP.NetworkMessages.Character minion = 3;
  total_size += 1 * this->minion_size();
  for (int i = 0; i < this->minion_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->minion(i));
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 4;
  total_size += 1 * this->position_size();
  for (int i = 0; i < this->position_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->position(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Character::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Character* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Character*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Character::MergeFrom(const Character& from) {
  GOOGLE_CHECK_NE(&from, this);
  minion_.MergeFrom(from.minion_);
  position_.MergeFrom(from.position_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_guid(from.guid());
    }
    if (from._has_bit(1)) {
      set_name(from.name());
    }
    if (from._has_bit(4)) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Character::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Character::CopyFrom(const Character& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Character::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < minion_size(); i++) {
    if (!this->minion(i).IsInitialized()) return false;
  }
  for (int i = 0; i < position_size(); i++) {
    if (!this->position(i).IsInitialized()) return false;
  }
  return true;
}

void Character::Swap(Character* other) {
  if (other != this) {
    std::swap(guid_, other->guid_);
    std::swap(name_, other->name_);
    minion_.Swap(&other->minion_);
    position_.Swap(&other->position_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Character::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Character_descriptor_;
  metadata.reflection = Character_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Equipment::kGuidFieldNumber;
const int Equipment::kSlotFieldNumber;
const int Equipment::kIdFieldNumber;
#endif  // !_MSC_VER

Equipment::Equipment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Equipment::InitAsDefaultInstance() {
}

Equipment::Equipment(const Equipment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Equipment::SharedCtor() {
  _cached_size_ = 0;
  guid_ = GOOGLE_LONGLONG(0);
  slot_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Equipment::~Equipment() {
  SharedDtor();
}

void Equipment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Equipment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Equipment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Equipment_descriptor_;
}

const Equipment& Equipment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

Equipment* Equipment::default_instance_ = NULL;

Equipment* Equipment::New() const {
  return new Equipment;
}

void Equipment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    guid_ = GOOGLE_LONGLONG(0);
    slot_ = 0;
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Equipment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 guid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &guid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_slot;
        break;
      }
      
      // optional int32 slot = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &slot_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }
      
      // required int32 id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Equipment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 guid = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->guid(), output);
  }
  
  // optional int32 slot = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->slot(), output);
  }
  
  // required int32 id = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Equipment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 guid = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->guid(), target);
  }
  
  // optional int32 slot = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->slot(), target);
  }
  
  // required int32 id = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Equipment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 guid = 1;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->guid());
    }
    
    // optional int32 slot = 2;
    if (has_slot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->slot());
    }
    
    // required int32 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Equipment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Equipment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Equipment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Equipment::MergeFrom(const Equipment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_guid(from.guid());
    }
    if (from._has_bit(1)) {
      set_slot(from.slot());
    }
    if (from._has_bit(2)) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Equipment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Equipment::CopyFrom(const Equipment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Equipment::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  return true;
}

void Equipment::Swap(Equipment* other) {
  if (other != this) {
    std::swap(guid_, other->guid_);
    std::swap(slot_, other->slot_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Equipment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Equipment_descriptor_;
  metadata.reflection = Equipment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Version::kVersionFieldNumber;
#endif  // !_MSC_VER

Version::Version()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Version::InitAsDefaultInstance() {
}

Version::Version(const Version& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Version::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Version::~Version() {
  SharedDtor();
}

void Version::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Version::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Version::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Version_descriptor_;
}

const Version& Version::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

Version* Version::default_instance_ = NULL;

Version* Version::New() const {
  return new Version;
}

void Version::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Version::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Version::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Version::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Version::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Version::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Version* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Version*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Version::MergeFrom(const Version& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Version::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Version::CopyFrom(const Version& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Version::Swap(Version* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Version::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Version_descriptor_;
  metadata.reflection = Version_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GameHasStarted::kStartedFieldNumber;
#endif  // !_MSC_VER

GameHasStarted::GameHasStarted()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameHasStarted::InitAsDefaultInstance() {
}

GameHasStarted::GameHasStarted(const GameHasStarted& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameHasStarted::SharedCtor() {
  _cached_size_ = 0;
  started_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameHasStarted::~GameHasStarted() {
  SharedDtor();
}

void GameHasStarted::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameHasStarted::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameHasStarted::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameHasStarted_descriptor_;
}

const GameHasStarted& GameHasStarted::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

GameHasStarted* GameHasStarted::default_instance_ = NULL;

GameHasStarted* GameHasStarted::New() const {
  return new GameHasStarted;
}

void GameHasStarted::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    started_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameHasStarted::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool started = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &started_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameHasStarted::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool started = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->started(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameHasStarted::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool started = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->started(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameHasStarted::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool started = 1;
    if (has_started()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameHasStarted::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameHasStarted* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameHasStarted*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameHasStarted::MergeFrom(const GameHasStarted& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_started(from.started());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameHasStarted::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameHasStarted::CopyFrom(const GameHasStarted& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameHasStarted::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GameHasStarted::Swap(GameHasStarted* other) {
  if (other != this) {
    std::swap(started_, other->started_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameHasStarted::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameHasStarted_descriptor_;
  metadata.reflection = GameHasStarted_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GameStarted::GameStarted()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameStarted::InitAsDefaultInstance() {
}

GameStarted::GameStarted(const GameStarted& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameStarted::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameStarted::~GameStarted() {
  SharedDtor();
}

void GameStarted::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameStarted::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameStarted::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameStarted_descriptor_;
}

const GameStarted& GameStarted::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

GameStarted* GameStarted::default_instance_ = NULL;

GameStarted* GameStarted::New() const {
  return new GameStarted;
}

void GameStarted::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameStarted::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GameStarted::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameStarted::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameStarted::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameStarted::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameStarted* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameStarted*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameStarted::MergeFrom(const GameStarted& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameStarted::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameStarted::CopyFrom(const GameStarted& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameStarted::IsInitialized() const {
  
  return true;
}

void GameStarted::Swap(GameStarted* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameStarted::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameStarted_descriptor_;
  metadata.reflection = GameStarted_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GameEnded::GameEnded()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameEnded::InitAsDefaultInstance() {
}

GameEnded::GameEnded(const GameEnded& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameEnded::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameEnded::~GameEnded() {
  SharedDtor();
}

void GameEnded::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameEnded::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameEnded::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameEnded_descriptor_;
}

const GameEnded& GameEnded::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

GameEnded* GameEnded::default_instance_ = NULL;

GameEnded* GameEnded::New() const {
  return new GameEnded;
}

void GameEnded::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameEnded::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GameEnded::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameEnded::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameEnded::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameEnded::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameEnded* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameEnded*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameEnded::MergeFrom(const GameEnded& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameEnded::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEnded::CopyFrom(const GameEnded& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEnded::IsInitialized() const {
  
  return true;
}

void GameEnded::Swap(GameEnded* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameEnded::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameEnded_descriptor_;
  metadata.reflection = GameEnded_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GameEnter::GameEnter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameEnter::InitAsDefaultInstance() {
}

GameEnter::GameEnter(const GameEnter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameEnter::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameEnter::~GameEnter() {
  SharedDtor();
}

void GameEnter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameEnter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameEnter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameEnter_descriptor_;
}

const GameEnter& GameEnter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

GameEnter* GameEnter::default_instance_ = NULL;

GameEnter* GameEnter::New() const {
  return new GameEnter;
}

void GameEnter::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameEnter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GameEnter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameEnter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameEnter::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameEnter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameEnter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameEnter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameEnter::MergeFrom(const GameEnter& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameEnter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEnter::CopyFrom(const GameEnter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEnter::IsInitialized() const {
  
  return true;
}

void GameEnter::Swap(GameEnter* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameEnter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameEnter_descriptor_;
  metadata.reflection = GameEnter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GameExited::GameExited()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GameExited::InitAsDefaultInstance() {
}

GameExited::GameExited(const GameExited& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GameExited::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameExited::~GameExited() {
  SharedDtor();
}

void GameExited::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameExited::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameExited::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameExited_descriptor_;
}

const GameExited& GameExited::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

GameExited* GameExited::default_instance_ = NULL;

GameExited* GameExited::New() const {
  return new GameExited;
}

void GameExited::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GameExited::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GameExited::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GameExited::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GameExited::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameExited::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GameExited* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GameExited*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameExited::MergeFrom(const GameExited& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GameExited::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameExited::CopyFrom(const GameExited& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameExited::IsInitialized() const {
  
  return true;
}

void GameExited::Swap(GameExited* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GameExited::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameExited_descriptor_;
  metadata.reflection = GameExited_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RequestCharacterInfo::RequestCharacterInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RequestCharacterInfo::InitAsDefaultInstance() {
}

RequestCharacterInfo::RequestCharacterInfo(const RequestCharacterInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RequestCharacterInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCharacterInfo::~RequestCharacterInfo() {
  SharedDtor();
}

void RequestCharacterInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RequestCharacterInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestCharacterInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestCharacterInfo_descriptor_;
}

const RequestCharacterInfo& RequestCharacterInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

RequestCharacterInfo* RequestCharacterInfo::default_instance_ = NULL;

RequestCharacterInfo* RequestCharacterInfo::New() const {
  return new RequestCharacterInfo;
}

void RequestCharacterInfo::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RequestCharacterInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void RequestCharacterInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RequestCharacterInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RequestCharacterInfo::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCharacterInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RequestCharacterInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RequestCharacterInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestCharacterInfo::MergeFrom(const RequestCharacterInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RequestCharacterInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestCharacterInfo::CopyFrom(const RequestCharacterInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCharacterInfo::IsInitialized() const {
  
  return true;
}

void RequestCharacterInfo::Swap(RequestCharacterInfo* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RequestCharacterInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestCharacterInfo_descriptor_;
  metadata.reflection = RequestCharacterInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReplyCharacterInfo::kPlayerFieldNumber;
#endif  // !_MSC_VER

ReplyCharacterInfo::ReplyCharacterInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReplyCharacterInfo::InitAsDefaultInstance() {
}

ReplyCharacterInfo::ReplyCharacterInfo(const ReplyCharacterInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReplyCharacterInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReplyCharacterInfo::~ReplyCharacterInfo() {
  SharedDtor();
}

void ReplyCharacterInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReplyCharacterInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReplyCharacterInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplyCharacterInfo_descriptor_;
}

const ReplyCharacterInfo& ReplyCharacterInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

ReplyCharacterInfo* ReplyCharacterInfo::default_instance_ = NULL;

ReplyCharacterInfo* ReplyCharacterInfo::New() const {
  return new ReplyCharacterInfo;
}

void ReplyCharacterInfo::Clear() {
  player_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReplyCharacterInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .TLMP.NetworkMessages.Character player = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_player;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReplyCharacterInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .TLMP.NetworkMessages.Character player = 1;
  for (int i = 0; i < this->player_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->player(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReplyCharacterInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .TLMP.NetworkMessages.Character player = 1;
  for (int i = 0; i < this->player_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->player(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReplyCharacterInfo::ByteSize() const {
  int total_size = 0;
  
  // repeated .TLMP.NetworkMessages.Character player = 1;
  total_size += 1 * this->player_size();
  for (int i = 0; i < this->player_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplyCharacterInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReplyCharacterInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReplyCharacterInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReplyCharacterInfo::MergeFrom(const ReplyCharacterInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_.MergeFrom(from.player_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReplyCharacterInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReplyCharacterInfo::CopyFrom(const ReplyCharacterInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplyCharacterInfo::IsInitialized() const {
  
  for (int i = 0; i < player_size(); i++) {
    if (!this->player(i).IsInitialized()) return false;
  }
  return true;
}

void ReplyCharacterInfo::Swap(ReplyCharacterInfo* other) {
  if (other != this) {
    player_.Swap(&other->player_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReplyCharacterInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReplyCharacterInfo_descriptor_;
  metadata.reflection = ReplyCharacterInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReplyCharacterId::kIdFieldNumber;
#endif  // !_MSC_VER

ReplyCharacterId::ReplyCharacterId()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReplyCharacterId::InitAsDefaultInstance() {
}

ReplyCharacterId::ReplyCharacterId(const ReplyCharacterId& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReplyCharacterId::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReplyCharacterId::~ReplyCharacterId() {
  SharedDtor();
}

void ReplyCharacterId::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReplyCharacterId::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReplyCharacterId::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplyCharacterId_descriptor_;
}

const ReplyCharacterId& ReplyCharacterId::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

ReplyCharacterId* ReplyCharacterId::default_instance_ = NULL;

ReplyCharacterId* ReplyCharacterId::New() const {
  return new ReplyCharacterId;
}

void ReplyCharacterId::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReplyCharacterId::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReplyCharacterId::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReplyCharacterId::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReplyCharacterId::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReplyCharacterId::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReplyCharacterId* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReplyCharacterId*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReplyCharacterId::MergeFrom(const ReplyCharacterId& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReplyCharacterId::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReplyCharacterId::CopyFrom(const ReplyCharacterId& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplyCharacterId::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ReplyCharacterId::Swap(ReplyCharacterId* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReplyCharacterId::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReplyCharacterId_descriptor_;
  metadata.reflection = ReplyCharacterId_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CharacterDestination::kIdFieldNumber;
const int CharacterDestination::kCurrentFieldNumber;
const int CharacterDestination::kDestinationFieldNumber;
#endif  // !_MSC_VER

CharacterDestination::CharacterDestination()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CharacterDestination::InitAsDefaultInstance() {
}

CharacterDestination::CharacterDestination(const CharacterDestination& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CharacterDestination::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CharacterDestination::~CharacterDestination() {
  SharedDtor();
}

void CharacterDestination::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CharacterDestination::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CharacterDestination::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CharacterDestination_descriptor_;
}

const CharacterDestination& CharacterDestination::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

CharacterDestination* CharacterDestination::default_instance_ = NULL;

CharacterDestination* CharacterDestination::New() const {
  return new CharacterDestination;
}

void CharacterDestination::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  current_.Clear();
  destination_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CharacterDestination::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_current;
        break;
      }
      
      // repeated .TLMP.NetworkMessages.Position current = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_current:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_current()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_current;
        if (input->ExpectTag(26)) goto parse_destination;
        break;
      }
      
      // repeated .TLMP.NetworkMessages.Position destination = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_destination:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_destination()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_destination;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CharacterDestination::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // repeated .TLMP.NetworkMessages.Position current = 2;
  for (int i = 0; i < this->current_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->current(i), output);
  }
  
  // repeated .TLMP.NetworkMessages.Position destination = 3;
  for (int i = 0; i < this->destination_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->destination(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CharacterDestination::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // repeated .TLMP.NetworkMessages.Position current = 2;
  for (int i = 0; i < this->current_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->current(i), target);
  }
  
  // repeated .TLMP.NetworkMessages.Position destination = 3;
  for (int i = 0; i < this->destination_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->destination(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CharacterDestination::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
  }
  // repeated .TLMP.NetworkMessages.Position current = 2;
  total_size += 1 * this->current_size();
  for (int i = 0; i < this->current_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->current(i));
  }
  
  // repeated .TLMP.NetworkMessages.Position destination = 3;
  total_size += 1 * this->destination_size();
  for (int i = 0; i < this->destination_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->destination(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CharacterDestination::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CharacterDestination* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CharacterDestination*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CharacterDestination::MergeFrom(const CharacterDestination& from) {
  GOOGLE_CHECK_NE(&from, this);
  current_.MergeFrom(from.current_);
  destination_.MergeFrom(from.destination_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CharacterDestination::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CharacterDestination::CopyFrom(const CharacterDestination& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CharacterDestination::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < current_size(); i++) {
    if (!this->current(i).IsInitialized()) return false;
  }
  for (int i = 0; i < destination_size(); i++) {
    if (!this->destination(i).IsInitialized()) return false;
  }
  return true;
}

void CharacterDestination::Swap(CharacterDestination* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    current_.Swap(&other->current_);
    destination_.Swap(&other->destination_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CharacterDestination::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CharacterDestination_descriptor_;
  metadata.reflection = CharacterDestination_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InventoryAddEquipment::kOwnerIdFieldNumber;
const int InventoryAddEquipment::kEquipmentIdFieldNumber;
const int InventoryAddEquipment::kSlotFieldNumber;
#endif  // !_MSC_VER

InventoryAddEquipment::InventoryAddEquipment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InventoryAddEquipment::InitAsDefaultInstance() {
}

InventoryAddEquipment::InventoryAddEquipment(const InventoryAddEquipment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InventoryAddEquipment::SharedCtor() {
  _cached_size_ = 0;
  ownerid_ = 0;
  equipmentid_ = 0;
  slot_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InventoryAddEquipment::~InventoryAddEquipment() {
  SharedDtor();
}

void InventoryAddEquipment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InventoryAddEquipment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InventoryAddEquipment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InventoryAddEquipment_descriptor_;
}

const InventoryAddEquipment& InventoryAddEquipment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

InventoryAddEquipment* InventoryAddEquipment::default_instance_ = NULL;

InventoryAddEquipment* InventoryAddEquipment::New() const {
  return new InventoryAddEquipment;
}

void InventoryAddEquipment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ownerid_ = 0;
    equipmentid_ = 0;
    slot_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InventoryAddEquipment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ownerId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ownerid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_equipmentId;
        break;
      }
      
      // required int32 equipmentId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_equipmentId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &equipmentid_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_slot;
        break;
      }
      
      // required int32 slot = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &slot_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InventoryAddEquipment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ownerId = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ownerid(), output);
  }
  
  // required int32 equipmentId = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->equipmentid(), output);
  }
  
  // required int32 slot = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->slot(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InventoryAddEquipment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ownerId = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ownerid(), target);
  }
  
  // required int32 equipmentId = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->equipmentid(), target);
  }
  
  // required int32 slot = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->slot(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InventoryAddEquipment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ownerId = 1;
    if (has_ownerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ownerid());
    }
    
    // required int32 equipmentId = 2;
    if (has_equipmentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->equipmentid());
    }
    
    // required int32 slot = 3;
    if (has_slot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->slot());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InventoryAddEquipment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InventoryAddEquipment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InventoryAddEquipment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InventoryAddEquipment::MergeFrom(const InventoryAddEquipment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_ownerid(from.ownerid());
    }
    if (from._has_bit(1)) {
      set_equipmentid(from.equipmentid());
    }
    if (from._has_bit(2)) {
      set_slot(from.slot());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InventoryAddEquipment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InventoryAddEquipment::CopyFrom(const InventoryAddEquipment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InventoryAddEquipment::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void InventoryAddEquipment::Swap(InventoryAddEquipment* other) {
  if (other != this) {
    std::swap(ownerid_, other->ownerid_);
    std::swap(equipmentid_, other->equipmentid_);
    std::swap(slot_, other->slot_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InventoryAddEquipment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InventoryAddEquipment_descriptor_;
  metadata.reflection = InventoryAddEquipment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Entity::kIdFieldNumber;
const int Entity::kLevelFieldNumber;
const int Entity::kGuidFieldNumber;
const int Entity::kNoItemsFieldNumber;
const int Entity::kDestinationFieldNumber;
const int Entity::kPositionFieldNumber;
#endif  // !_MSC_VER

Entity::Entity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Entity::InitAsDefaultInstance() {
  destination_ = const_cast< ::TLMP::NetworkMessages::Position*>(&::TLMP::NetworkMessages::Position::default_instance());
}

Entity::Entity(const Entity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Entity::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  level_ = 0;
  guid_ = GOOGLE_LONGLONG(0);
  noitems_ = false;
  destination_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entity::~Entity() {
  SharedDtor();
}

void Entity::SharedDtor() {
  if (this != default_instance_) {
    delete destination_;
  }
}

void Entity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entity_descriptor_;
}

const Entity& Entity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

Entity* Entity::default_instance_ = NULL;

Entity* Entity::New() const {
  return new Entity;
}

void Entity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    level_ = 0;
    guid_ = GOOGLE_LONGLONG(0);
    noitems_ = false;
    if (_has_bit(4)) {
      if (destination_ != NULL) destination_->::TLMP::NetworkMessages::Position::Clear();
    }
  }
  position_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }
      
      // required int32 level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_guid;
        break;
      }
      
      // required int64 guid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &guid_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_noItems;
        break;
      }
      
      // required bool noItems = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_noItems:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &noitems_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_destination;
        break;
      }
      
      // optional .TLMP.NetworkMessages.Position destination = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_destination:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_destination()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_position;
        break;
      }
      
      // repeated .TLMP.NetworkMessages.Position position = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_position;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Entity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int32 level = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->level(), output);
  }
  
  // required int64 guid = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->guid(), output);
  }
  
  // required bool noItems = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->noitems(), output);
  }
  
  // optional .TLMP.NetworkMessages.Position destination = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->destination(), output);
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 6;
  for (int i = 0; i < this->position_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->position(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Entity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int32 level = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->level(), target);
  }
  
  // required int64 guid = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->guid(), target);
  }
  
  // required bool noItems = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->noitems(), target);
  }
  
  // optional .TLMP.NetworkMessages.Position destination = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->destination(), target);
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 6;
  for (int i = 0; i < this->position_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->position(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Entity::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }
    
    // required int64 guid = 3;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->guid());
    }
    
    // required bool noItems = 4;
    if (has_noitems()) {
      total_size += 1 + 1;
    }
    
    // optional .TLMP.NetworkMessages.Position destination = 5;
    if (has_destination()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->destination());
    }
    
  }
  // repeated .TLMP.NetworkMessages.Position position = 6;
  total_size += 1 * this->position_size();
  for (int i = 0; i < this->position_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->position(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entity::MergeFrom(const Entity& from) {
  GOOGLE_CHECK_NE(&from, this);
  position_.MergeFrom(from.position_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_level(from.level());
    }
    if (from._has_bit(2)) {
      set_guid(from.guid());
    }
    if (from._has_bit(3)) {
      set_noitems(from.noitems());
    }
    if (from._has_bit(4)) {
      mutable_destination()->::TLMP::NetworkMessages::Position::MergeFrom(from.destination());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entity::CopyFrom(const Entity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_destination()) {
    if (!this->destination().IsInitialized()) return false;
  }
  for (int i = 0; i < position_size(); i++) {
    if (!this->position(i).IsInitialized()) return false;
  }
  return true;
}

void Entity::Swap(Entity* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(level_, other->level_);
    std::swap(guid_, other->guid_);
    std::swap(noitems_, other->noitems_);
    std::swap(destination_, other->destination_);
    position_.Swap(&other->position_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entity_descriptor_;
  metadata.reflection = Entity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Item::kIdFieldNumber;
const int Item::kGuidFieldNumber;
const int Item::kLevelFieldNumber;
const int Item::kUnk0FieldNumber;
const int Item::kUnk1FieldNumber;
#endif  // !_MSC_VER

Item::Item()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Item::InitAsDefaultInstance() {
}

Item::Item(const Item& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Item::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  guid_ = GOOGLE_LONGLONG(0);
  level_ = 0;
  unk0_ = 0;
  unk1_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Item::~Item() {
  SharedDtor();
}

void Item::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Item::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Item::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Item_descriptor_;
}

const Item& Item::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

Item* Item::default_instance_ = NULL;

Item* Item::New() const {
  return new Item;
}

void Item::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    guid_ = GOOGLE_LONGLONG(0);
    level_ = 0;
    unk0_ = 0;
    unk1_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Item::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_guid;
        break;
      }
      
      // required int64 guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &guid_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_level;
        break;
      }
      
      // required int32 level = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_unk0;
        break;
      }
      
      // required int32 unk0 = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unk0:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unk0_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_unk1;
        break;
      }
      
      // required int32 unk1 = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unk1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unk1_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Item::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int64 guid = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->guid(), output);
  }
  
  // required int32 level = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->level(), output);
  }
  
  // required int32 unk0 = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->unk0(), output);
  }
  
  // required int32 unk1 = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->unk1(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Item::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int64 guid = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->guid(), target);
  }
  
  // required int32 level = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->level(), target);
  }
  
  // required int32 unk0 = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->unk0(), target);
  }
  
  // required int32 unk1 = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->unk1(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Item::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int64 guid = 2;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->guid());
    }
    
    // required int32 level = 3;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }
    
    // required int32 unk0 = 4;
    if (has_unk0()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unk0());
    }
    
    // required int32 unk1 = 5;
    if (has_unk1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unk1());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Item::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Item* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Item*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Item::MergeFrom(const Item& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_guid(from.guid());
    }
    if (from._has_bit(2)) {
      set_level(from.level());
    }
    if (from._has_bit(3)) {
      set_unk0(from.unk0());
    }
    if (from._has_bit(4)) {
      set_unk1(from.unk1());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Item::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Item::CopyFrom(const Item& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void Item::Swap(Item* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(guid_, other->guid_);
    std::swap(level_, other->level_);
    std::swap(unk0_, other->unk0_);
    std::swap(unk1_, other->unk1_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Item::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Item_descriptor_;
  metadata.reflection = Item_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemDrop::kIdFieldNumber;
const int ItemDrop::kPositionFieldNumber;
const int ItemDrop::kUnk0FieldNumber;
#endif  // !_MSC_VER

ItemDrop::ItemDrop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemDrop::InitAsDefaultInstance() {
}

ItemDrop::ItemDrop(const ItemDrop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemDrop::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  unk0_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemDrop::~ItemDrop() {
  SharedDtor();
}

void ItemDrop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemDrop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemDrop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemDrop_descriptor_;
}

const ItemDrop& ItemDrop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

ItemDrop* ItemDrop::default_instance_ = NULL;

ItemDrop* ItemDrop::New() const {
  return new ItemDrop;
}

void ItemDrop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    unk0_ = false;
  }
  position_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemDrop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_position;
        break;
      }
      
      // repeated .TLMP.NetworkMessages.Position position = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_position;
        if (input->ExpectTag(24)) goto parse_unk0;
        break;
      }
      
      // required bool unk0 = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unk0:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unk0_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemDrop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 2;
  for (int i = 0; i < this->position_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->position(i), output);
  }
  
  // required bool unk0 = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->unk0(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemDrop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // repeated .TLMP.NetworkMessages.Position position = 2;
  for (int i = 0; i < this->position_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->position(i), target);
  }
  
  // required bool unk0 = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->unk0(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemDrop::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required bool unk0 = 3;
    if (has_unk0()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .TLMP.NetworkMessages.Position position = 2;
  total_size += 1 * this->position_size();
  for (int i = 0; i < this->position_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->position(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemDrop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemDrop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemDrop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemDrop::MergeFrom(const ItemDrop& from) {
  GOOGLE_CHECK_NE(&from, this);
  position_.MergeFrom(from.position_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(2)) {
      set_unk0(from.unk0());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemDrop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemDrop::CopyFrom(const ItemDrop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemDrop::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  for (int i = 0; i < position_size(); i++) {
    if (!this->position(i).IsInitialized()) return false;
  }
  return true;
}

void ItemDrop::Swap(ItemDrop* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    position_.Swap(&other->position_);
    std::swap(unk0_, other->unk0_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemDrop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemDrop_descriptor_;
  metadata.reflection = ItemDrop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemPickup::kIdFieldNumber;
const int ItemPickup::kOwnerIdFieldNumber;
#endif  // !_MSC_VER

ItemPickup::ItemPickup()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemPickup::InitAsDefaultInstance() {
}

ItemPickup::ItemPickup(const ItemPickup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemPickup::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ownerid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemPickup::~ItemPickup() {
  SharedDtor();
}

void ItemPickup::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemPickup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemPickup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemPickup_descriptor_;
}

const ItemPickup& ItemPickup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

ItemPickup* ItemPickup::default_instance_ = NULL;

ItemPickup* ItemPickup::New() const {
  return new ItemPickup;
}

void ItemPickup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    ownerid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemPickup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ownerId;
        break;
      }
      
      // required int32 ownerId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ownerId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ownerid_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemPickup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int32 ownerId = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ownerid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemPickup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int32 ownerId = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->ownerid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemPickup::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 ownerId = 2;
    if (has_ownerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ownerid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemPickup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemPickup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemPickup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemPickup::MergeFrom(const ItemPickup& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_ownerid(from.ownerid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemPickup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemPickup::CopyFrom(const ItemPickup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemPickup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void ItemPickup::Swap(ItemPickup* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(ownerid_, other->ownerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemPickup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemPickup_descriptor_;
  metadata.reflection = ItemPickup_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemEquip::kIdFieldNumber;
const int ItemEquip::kSlotFieldNumber;
const int ItemEquip::kOwnerIdFieldNumber;
const int ItemEquip::kUnkFieldNumber;
#endif  // !_MSC_VER

ItemEquip::ItemEquip()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemEquip::InitAsDefaultInstance() {
}

ItemEquip::ItemEquip(const ItemEquip& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemEquip::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  slot_ = 0;
  ownerid_ = 0;
  unk_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemEquip::~ItemEquip() {
  SharedDtor();
}

void ItemEquip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemEquip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemEquip::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemEquip_descriptor_;
}

const ItemEquip& ItemEquip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

ItemEquip* ItemEquip::default_instance_ = NULL;

ItemEquip* ItemEquip::New() const {
  return new ItemEquip;
}

void ItemEquip::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    slot_ = 0;
    ownerid_ = 0;
    unk_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemEquip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_slot;
        break;
      }
      
      // required int32 slot = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &slot_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ownerId;
        break;
      }
      
      // required int32 ownerId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ownerId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ownerid_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_unk;
        break;
      }
      
      // required int32 unk = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unk_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemEquip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int32 slot = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->slot(), output);
  }
  
  // required int32 ownerId = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ownerid(), output);
  }
  
  // required int32 unk = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->unk(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemEquip::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int32 slot = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->slot(), target);
  }
  
  // required int32 ownerId = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->ownerid(), target);
  }
  
  // required int32 unk = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->unk(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemEquip::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 slot = 2;
    if (has_slot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->slot());
    }
    
    // required int32 ownerId = 3;
    if (has_ownerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ownerid());
    }
    
    // required int32 unk = 4;
    if (has_unk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unk());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemEquip::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemEquip* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemEquip*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemEquip::MergeFrom(const ItemEquip& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_slot(from.slot());
    }
    if (from._has_bit(2)) {
      set_ownerid(from.ownerid());
    }
    if (from._has_bit(3)) {
      set_unk(from.unk());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemEquip::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemEquip::CopyFrom(const ItemEquip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemEquip::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void ItemEquip::Swap(ItemEquip* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(slot_, other->slot_);
    std::swap(ownerid_, other->ownerid_);
    std::swap(unk_, other->unk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemEquip::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemEquip_descriptor_;
  metadata.reflection = ItemEquip_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemUnequip::kIdFieldNumber;
const int ItemUnequip::kOwneridFieldNumber;
#endif  // !_MSC_VER

ItemUnequip::ItemUnequip()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemUnequip::InitAsDefaultInstance() {
}

ItemUnequip::ItemUnequip(const ItemUnequip& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemUnequip::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ownerid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemUnequip::~ItemUnequip() {
  SharedDtor();
}

void ItemUnequip::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemUnequip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemUnequip::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemUnequip_descriptor_;
}

const ItemUnequip& ItemUnequip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eproto();  return *default_instance_;
}

ItemUnequip* ItemUnequip::default_instance_ = NULL;

ItemUnequip* ItemUnequip::New() const {
  return new ItemUnequip;
}

void ItemUnequip::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    ownerid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemUnequip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ownerid;
        break;
      }
      
      // required int32 ownerid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ownerid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ownerid_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemUnequip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int32 ownerid = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ownerid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemUnequip::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int32 ownerid = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->ownerid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemUnequip::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 ownerid = 2;
    if (has_ownerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ownerid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemUnequip::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemUnequip* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemUnequip*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemUnequip::MergeFrom(const ItemUnequip& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_ownerid(from.ownerid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemUnequip::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemUnequip::CopyFrom(const ItemUnequip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemUnequip::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void ItemUnequip::Swap(ItemUnequip* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(ownerid_, other->ownerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemUnequip::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemUnequip_descriptor_;
  metadata.reflection = ItemUnequip_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NetworkMessages
}  // namespace TLMP

// @@protoc_insertion_point(global_scope)
